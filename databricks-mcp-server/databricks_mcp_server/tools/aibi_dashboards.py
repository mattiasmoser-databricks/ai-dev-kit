"""AI/BI Dashboard tools - Create and manage AI/BI dashboards.

Note: AI/BI dashboards were previously known as Lakeview dashboards.
The SDK/API still uses the 'lakeview' name internally.

Dashboard JSON content should be generated by the AI assistant using
the aibi-dashboards skill documentation, then deployed via these tools.
"""

from typing import Any, Dict

from databricks_tools_core.aibi_dashboards import (
    create_or_update_dashboard as _create_or_update_dashboard,
    get_dashboard as _get_dashboard,
    list_dashboards as _list_dashboards,
    publish_dashboard as _publish_dashboard,
    trash_dashboard as _trash_dashboard,
    unpublish_dashboard as _unpublish_dashboard,
)

from ..server import mcp


# ============================================================================
# Primary Dashboard Tool
# ============================================================================


@mcp.tool
def create_or_update_dashboard(
    display_name: str,
    parent_path: str,
    serialized_dashboard: str,
    warehouse_id: str,
    publish: bool = True,
) -> Dict[str, Any]:
    """Create or update an AI/BI dashboard from JSON content.

    CRITICAL PRE-REQUISITES (DO NOT SKIP):
    Before calling this tool, you MUST:
    1. Call get_table_details() to get table schemas
    2. Call execute_sql() to TEST EVERY dataset query - if any fail, fix them first!
    3. Verify query results have expected columns and data types

    If you skip validation, widgets WILL show "Invalid widget definition" errors!

    DASHBOARD JSON REQUIREMENTS:

    Dataset Architecture:
    - One dataset per domain (orders, customers, products)
    - Exactly ONE SQL query per dataset (no semicolon-separated queries)
    - Use fully-qualified table names: catalog.schema.table_name
    - All widget fieldNames must match dataset column names exactly

    Widget Field Expressions (ONLY these are allowed):
    - Aggregates: SUM(`col`), AVG(`col`), COUNT(`col`), COUNT(DISTINCT `col`), MIN(`col`), MAX(`col`)
    - Date truncation: DATE_TRUNC("DAY", `date`), DATE_TRUNC("WEEK", `date`), DATE_TRUNC("MONTH", `date`)
    - Simple reference: `column_name`
    - NO CAST, no complex SQL - put logic in dataset query instead

    Layout (6-column grid, NO GAPS):
    - Each row must total width=6 exactly
    - Counter/KPI: width=2, height=3-4 (NEVER height=2)
    - Charts: width=3, height=5-6
    - Tables: width=6, height=5-8
    - Text headers: width=6, height=1-2

    Widget Naming:
    - widget.name: alphanumeric + hyphens + underscores ONLY (no spaces/parentheses/colons)
    - frame.title: human-readable name (any characters)
    - widget.queries[0].name: always "main_query"

    Counter widgets:
    - Dataset must return exactly 1 row
    - Use "disaggregated": true in query
    - Percent values must be 0-1 (not 0-100)

    Charts (line/bar):
    - Use "disaggregated": true with pre-aggregated data
    - scale.type: "temporal" (dates), "quantitative" (numbers), "categorical" (strings)
    - Limit color/grouping dimensions to 3-8 distinct values

    SQL Patterns (Spark SQL):
    - Date math: date_sub(current_date(), N), add_months(current_date(), -N)
    - AVOID INTERVAL syntax - use functions instead

    Args:
        display_name: Dashboard display name
        parent_path: Workspace folder path (e.g., "/Workspace/Users/me/dashboards")
        serialized_dashboard: Dashboard JSON content as string (MUST be tested first!)
        warehouse_id: SQL warehouse ID for query execution
        publish: Whether to publish after creation (default: True)

    Returns:
        Dictionary with:
        - success: Whether operation succeeded
        - status: 'created' or 'updated'
        - dashboard_id: Dashboard ID
        - path: Full workspace path
        - url: Dashboard URL
        - published: Whether dashboard was published
        - error: Error message if failed
    """
    return _create_or_update_dashboard(
        display_name=display_name,
        parent_path=parent_path,
        serialized_dashboard=serialized_dashboard,
        warehouse_id=warehouse_id,
        publish=publish,
    )


# ============================================================================
# CRUD Operations
# ============================================================================


@mcp.tool
def get_dashboard(dashboard_id: str) -> Dict[str, Any]:
    """Get AI/BI dashboard details by ID.

    Args:
        dashboard_id: The dashboard ID

    Returns:
        Dictionary with dashboard details including:
        - dashboard_id: The dashboard ID
        - display_name: Dashboard display name
        - warehouse_id: Associated SQL warehouse
        - parent_path: Workspace path
        - path: Full workspace path
        - lifecycle_state: Current state (ACTIVE, TRASHED, etc.)
        - serialized_dashboard: Dashboard JSON content (if available)

    Example:
        >>> get_dashboard("abc123")
        {
        ...     "dashboard_id": "abc123",
        ...     "display_name": "Sales Dashboard",
        ...     "warehouse_id": "def456",
        ...     "parent_path": "/Workspace/Users/me/dashboards",
        ... }
    """
    return _get_dashboard(dashboard_id=dashboard_id)


@mcp.tool
def list_dashboards(page_size: int = 25) -> Dict[str, Any]:
    """List AI/BI dashboards in the workspace.

    Args:
        page_size: Number of dashboards to return (default: 25)

    Returns:
        Dictionary with:
        - dashboards: List of dashboard summaries (id, name, path, state)

    Example:
        >>> list_dashboards(page_size=10)
        {
        ...     "dashboards": [
        ...         {"dashboard_id": "abc", "display_name": "Sales", ...},
        ...         {"dashboard_id": "def", "display_name": "Marketing", ...}
        ...     ]
        ... }
    """
    return _list_dashboards(page_size=page_size)


@mcp.tool
def trash_dashboard(dashboard_id: str) -> Dict[str, str]:
    """Move an AI/BI dashboard to trash.

    Args:
        dashboard_id: Dashboard ID to trash

    Returns:
        Dictionary with status message

    Example:
        >>> trash_dashboard("abc123")
        {
        ...     "status": "success",
        ...     "message": "Dashboard abc123 moved to trash",
        ...     "dashboard_id": "abc123"
        ... }
    """
    return _trash_dashboard(dashboard_id=dashboard_id)


@mcp.tool
def publish_dashboard(
    dashboard_id: str,
    warehouse_id: str,
    embed_credentials: bool = True,
) -> Dict[str, Any]:
    """Publish an AI/BI dashboard to make it accessible to viewers.

    Publishing with embed_credentials=True allows users without direct
    data access to view the dashboard (queries execute using the
    service principal's permissions).

    Args:
        dashboard_id: Dashboard ID to publish
        warehouse_id: SQL warehouse ID for query execution
        embed_credentials: Whether to embed credentials (default: True)

    Returns:
        Dictionary with:
        - status: "published"
        - dashboard_id: The dashboard ID
        - url: Dashboard URL
        - embed_credentials: Whether credentials are embedded

    Example:
        >>> publish_dashboard("abc123", "warehouse456")
        {
        ...     "status": "published",
        ...     "dashboard_id": "abc123",
        ...     "url": "https://workspace.../sql/dashboardsv3/abc123",
        ...     "embed_credentials": True
        ... }
    """
    return _publish_dashboard(
        dashboard_id=dashboard_id,
        warehouse_id=warehouse_id,
        embed_credentials=embed_credentials,
    )


@mcp.tool
def unpublish_dashboard(dashboard_id: str) -> Dict[str, str]:
    """Unpublish an AI/BI dashboard.

    Args:
        dashboard_id: Dashboard ID to unpublish

    Returns:
        Dictionary with status message

    Example:
        >>> unpublish_dashboard("abc123")
        {
        ...     "status": "unpublished",
        ...     "message": "Dashboard abc123 unpublished",
        ...     "dashboard_id": "abc123"
        ... }
    """
    return _unpublish_dashboard(dashboard_id=dashboard_id)
